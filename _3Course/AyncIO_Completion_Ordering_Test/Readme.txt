Overlapped IO는 순서가 반드시 보장되서 q에 들어온다고 하였다. 
Overlapped IO는 동기로 실행될 경우와 비동기로 실행될경우가 나뉘는데,

Send의 경우 송신버퍼에 데이터의 공간이  부족할 때 비동기로 작동된다고한다.

만일 송신버퍼의 크기가 100만큼 남았을때  WSASend( Len = 1000 ) , WSASend( Len 50 ) 을 한다면,

1. WSASend는 비동기 와 동기 WSASend가 작동할 것이다.
완료통지는 GQCS에 대해서 들어오게되고, 완료통지가 도착하면 완료 통지 Q에서 빼는 작업을 실행한다.

만일 동기와 비동기가 순서가 지켜진다면, 

무조건 비동기가 먼저 와야한다.  그러나 동기의 경우 송신버퍼에 복사하고 완료통지에 삽입 되므로  순서가 지켜지지않을 것으로 보이나.

동기와 비동기는 순서가 지켜진다고한다.

과연 정말로 그럴까?

=> 사실 어차피 중복 WSASend를 쓰지않을 것이므로 안쓰겟지만 될 것같은데.. 논리적으로


실험 방법 :
송신 버퍼의 크기가 부족해야한다. => 클라이언트에서 Recv를 작동시키지 않는다.
처음에는 10000 크기씩  덩어리로 보내다가. IO_Pending 이 뜨는 것을 확인하고, 'A'key를 입력하여 Send1byte   스레드를 실행시킨다.
특정 스레드는 1크기를 WSASend하는 코드를 'A'라는 키를 입력받아 실행된다.
반환값이 IO_PENDING이 아니라면 성공이다.

이 상황에서 GQCS에서  KEY을 통해 순서가 지켜지는지 확인 할 수 있다.

Key값은  interlock으로 제대로 1씩 증가시키면서 GQCS 쓰레드를 1개만 작성하면  순서를 제대로 알 수 있을것이다.